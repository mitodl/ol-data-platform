"""
Synchronize and process edx.org data archives and tracking logs.

The current flow of data from edx.org into the Open Learning data platform is routed
through IRx (MIT Institutional Research).

The data that we receive from edx.org is produced as two separate formats.  Tracking
logs are provided to us from IRx as individual gzipped JSONL files containing the
tracking events.  The remainder of the data is generated via the Analytics Exporter
logic found at https://github.com/openedx/edx-analytics-exporter/

The data packages contained in the tar.gz files generated by the analytics exporter are
segmented by course ID.  For each course, we receive:

    - A series of TSV files (with a .sql extension) that are representations of data
      pulled from the edX MySQL database

    - A BSON dump of the forum data for the course

    - A tar.gz archive of the course XML as generated by the edX course export
      functionality

For integration with the Open Learning platform, the tracking logs are synchronized and
processed so that nested JSON objects are 'stringified'.  This ensures that we are able
to process the nested documents via the Trino query engine.

The course archives are unpacked and uploaded to different S3 destinations.  The TSV
files are ingested and processed via Airbyte so that the structured data can be queried
via Trino and processed with dbt.  The course XML archives are processed to determine
the duration values of video elements.  There is also a course structure document that
is used to enrich the tracking events.

The overall flow of data is as follows:

    - Tracking Logs:

        1. Download the edX tracking logs from the Google Cloud Storage bucket owned by
           IRx.

        2. Normalize the log records

        3. Upload the normalized records as JSONL files to S3

        4. Ingest the tracking logs via Airbyte

    - Course data archives:

        1. Download the edX course export data from the Google Cloud Storage bucket
           owned by IRx.

        2. Enumerate the contents of the archive:

            - Upload TSV files to a /csv prefix in S3 for ingestion via Airbyte

            - Process course structure documents and upload as JSONL files to S3 for
              ingestion via Airbyte

            - Upload BSON files to a /forum prefix in S3

            - Upload XML files to a /courses prefix in S3
"""

import re
from functools import partial
from typing import Any, Literal

from dagster import (
    AssetSelection,
    DefaultSensorStatus,
    Definitions,
    SensorDefinition,
    define_asset_job,
)
from dagster_aws.s3 import S3Resource

from ol_orchestrate.assets.edxorg_archive import (
    gcs_edxorg_archive_sensor,
    process_edxorg_archive_bundle,
)
from ol_orchestrate.jobs.retrieve_edx_exports import (
    retrieve_edx_tracking_logs,
)
from ol_orchestrate.lib.constants import DAGSTER_ENV, VAULT_ADDRESS
from ol_orchestrate.resources.gcp_gcs import GCSConnection
from ol_orchestrate.resources.outputs import DailyResultsDir
from ol_orchestrate.resources.secrets.vault import Vault
from ol_orchestrate.sensors.object_storage import gcs_multi_file_sensor

if DAGSTER_ENV == "dev":
    vault = Vault(vault_addr=VAULT_ADDRESS, vault_auth_type="github")
    vault._auth_github()  # noqa: SLF001
else:
    vault = Vault(
        vault_addr=VAULT_ADDRESS, vault_role="dagster-server", aws_auth_mount="aws"
    )
    vault._auth_aws_iam()  # noqa: SLF001


def s3_uploads_bucket(
    dagster_env: Literal["dev", "qa", "production"],
) -> dict[str, Any]:
    bucket_map = {
        "dev": {"bucket": "ol-devops-sandbox", "prefix": "pipeline-storage"},
        "qa": {"bucket": "ol-data-lake-landing-zone-qa", "prefix": "edxorg-raw-data"},
        "production": {
            "bucket": "ol-data-lake-landing-zone-production",
            "prefix": "edxorg-raw-data",
        },
    }
    return bucket_map[dagster_env]


def edxorg_data_archive_config(
    irx_edxorg_gcs_bucket, ol_edxorg_raw_data_bucket, new_files_to_sync
):
    return {
        "ops": {
            "download_edx_data_exports": {
                "config": {
                    "irx_edxorg_gcs_bucket": irx_edxorg_gcs_bucket,
                    "export_type": "courses",
                    "files_to_sync": list(new_files_to_sync),
                }
            },
            "upload_edx_data_exports": {
                "config": {
                    "edx_irx_exports_bucket": ol_edxorg_raw_data_bucket,
                    "bucket_prefix": s3_uploads_bucket(DAGSTER_ENV)["prefix"],
                }
            },
        }
    }


def edxorg_tracking_logs_config(
    irx_edxorg_gcs_bucket, ol_edxorg_raw_data_bucket, new_files_to_sync
):
    return {
        "ops": {
            "download_edx_data_exports": {
                "config": {
                    "irx_edxorg_gcs_bucket": irx_edxorg_gcs_bucket,
                    "export_type": "logs",
                    "files_to_sync": list(new_files_to_sync),
                }
            },
            "upload_edx_data_exports": {
                "config": {
                    "edx_irx_exports_bucket": ol_edxorg_raw_data_bucket,
                    "bucket_prefix": s3_uploads_bucket(DAGSTER_ENV)["prefix"],
                }
            },
        }
    }


s3_course_assets_job = define_asset_job(
    name="edxorg_raw_course_data",
    selection=AssetSelection.key_prefixes("edxorg", "raw_data"),
)

s3_logs_job_def = retrieve_edx_tracking_logs.to_job(
    name="retrieve_edx_logs",
    config=edxorg_tracking_logs_config(
        "simeon-mitx-pipeline-main", s3_uploads_bucket(DAGSTER_ENV)["bucket"], set()
    ),
)

file_regex = {
    "courses": r"COLD/mitx-\d{4}-\d{2}-\d{2}.tar.gz$",
    "logs": r"COLD/mitx-edx-events-\d{4}-\d{2}-\d{2}.log.gz$",
}

retrieve_edx_exports = Definitions(
    resources={
        "gcp_gcs": GCSConnection(
            **vault.client.secrets.kv.v1.read_secret(
                mount_point="secret-data", path="pipelines/edx/org/gcp-oauth-client"
            )["data"]
        ),
        "s3": S3Resource(),
        "exports_dir": DailyResultsDir.configure_at_launch(),
    },
    sensors=[
        gcs_edxorg_archive_sensor,
        SensorDefinition(
            name="logs_sensor",
            evaluation_fn=partial(
                gcs_multi_file_sensor,
                "simeon-mitx-pipeline-main",
                bucket_prefix="COLD/",
                object_filter_fn=lambda object_key: re.match(
                    file_regex["logs"], object_key
                ),
                run_config_fn=lambda new_keys: edxorg_tracking_logs_config(
                    "simeon-mitx-pipeline-main",
                    s3_uploads_bucket(DAGSTER_ENV)["bucket"],
                    new_keys,
                ),
            ),
            minimum_interval_seconds=86400,
            job=s3_logs_job_def,
            default_status=DefaultSensorStatus.RUNNING,
        ),
    ],
    jobs=[s3_course_assets_job, s3_logs_job_def],
    assets=[process_edxorg_archive_bundle],
)
